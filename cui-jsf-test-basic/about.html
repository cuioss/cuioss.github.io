<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/asciidoc/about.adoc at 2023-03-09
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>cui jsf test basic &#x2013; </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.11.1.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>cui jsf test basic</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2023-03-09<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.1.0-SNAPSHOT</li>
        <li class="pull-right"><a href="https://github.com/cuioss/cui-jsf-test-basic" class="externalLink" title="Home">Home</a></li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li class="active"><a><span class="none"></span>About</a></li>
    <li><a href="apidocs/index.html" title="JavaDoc"><span class="none"></span>JavaDoc</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<div class="sect1">
<h2 id="about">About</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Extension for <a href="http://myfaces.apache.org/test/index.html">MyFaces-Test</a> that uses the mock-based infrastructure and adds certain aspects in order to simplify its usage in the portal-context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Convenient programmatic configuration of JSF-context</p>
</li>
<li>
<p>Specific base-classes for conveniently testing aspects like</p>
<div class="ulist">
<ul>
<li>
<p><code>AbstractBeanTest</code></p>
</li>
<li>
<p><code>AbstractValidatorTest</code></p>
</li>
<li>
<p><code>AbstractConverterTest</code></p>
</li>
<li>
<p><code>AbstractComponentTest</code></p>
</li>
<li>
<p><code>AbstractUiComponentTest</code></p>
</li>
<li>
<p><code>AbstractComponentRendererTest</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Tooling for generating (partial-) HTML-trees including the corresponding Assertions</p>
</li>
<li>
<p>Additional Mocks completing the ones provided from myfaces-test</p>
</li>
<li>
<p>Integration into <a href="https://github.com/cuioss/cui-test-value-objects">cui-test-value-objects</a> framework</p>
</li>
<li>
<p>Baseline is JSF 2.3</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how_to_use_it">How To use it</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="caution">Caution</h3>
<div class="paragraph">
<p>Due to an implementation-issue of the underlying <code>myfaces-test</code> this library must use the <code>myfaces-api</code> to compile / run against.
Otherwise there may popup some strange class-loader-issues, especially on parallel execution.</p>
</div>
</div>
<div class="sect2">
<h3 id="simple_usage">Simple Usage</h3>
<div class="paragraph">
<p>If you want to add a complete JSF-runtime-setup to a certain test just add the annotation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJsfEnvironment
class FacesTestEnabledTest {</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding extension takes care for handling the JSF-Setup including resetting it for each test.</p>
</div>
</div>
<div class="sect2">
<h3 id="add_configuration">Add Configuration</h3>
<div class="paragraph">
<p>As a next step you can add additional configuration. This can be done either by type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJsfEnvironment
@JsfTestConfiguration(BasicApplicationConfiguration.class)
class FacesTestEnabledTest {</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or via callback interface</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJsfEnvironment
class AccordionRendererTest
        extends AbstractComponentRendererTest&lt;AccordionRenderer&gt; implements ComponentConfigurator {

    @Override
    public void configureComponents(final ComponentConfigDecorator decorator) {
        decorator.registerRenderer(BootstrapPanelRenderer.class);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The framework takes care of calling the callback methods at the correct time prior to each test</p>
</div>
<div class="paragraph">
<p>Available Extension-Types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>de.cuioss.test.jsf.config.ApplicationConfigurator</code></p>
</li>
<li>
<p><code>de.cuioss.test.jsf.config.BeanConfigurator</code> &#8594; ManagedBean &#8594; Will be removed</p>
</li>
<li>
<p><code>de.cuioss.test.jsf.config.ComponentConfigurator</code></p>
</li>
<li>
<p><code>de.cuioss.test.jsf.config.RequestConfigurator</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Corresponding Configurator-Types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>de.cuioss.test.jsf.config.decorator.ApplicationConfigDecorator</code></p>
</li>
<li>
<p><code>de.cuioss.test.jsf.config.decorator.BeanConfigDecorator</code> &#8594; ManagedBean &#8594; Will be removed</p>
</li>
<li>
<p><code>de.cuioss.test.jsf.config.decorator.ComponentConfigDecorator</code></p>
</li>
<li>
<p><code>de.cuioss.test.jsf.config.decorator.RequestConfigDecorator</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the javadoc-documentation for the actual usage</p>
</div>
</div>
<div class="sect2">
<h3 id="fine_grained_control">Fine grained control</h3>
<div class="paragraph">
<p>For cases you want to modify the tests more fine grained or want to have access on <code>FacesContext</code>, <code>ExternalContext</code> and Co. you can use <code>de.cuioss.test.jsf.util.JsfEnvironmentConsumer</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJsfEnvironment
class FacesTestEnabledTest implements JsfEnvironmentConsumer {

    @Setter
    @Getter
    private JsfEnvironmentHolder environmentHolder;

    @Test
    void shouldProvideJsfObjects() {
        assertNotNull(environmenHolder);
        assertNotNull(getApplication());
        assertNotNull(getApplicationConfigDecorator());
        assertNotNull(getBeanConfigDecorator());
        assertNotNull(getComponentConfigDecorator());
        assertNotNull(getExternalContext());
        assertNotNull(getFacesContext());
        assertNotNull(getRequestConfigDecorator());
        assertNotNull(getResponse());
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, it provides two navigation related assertions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJsfEnvironment
class FacesTestEnabledTest implements JsfEnvironmentConsumer {
  @Setter
  @Getter
  private JsfEnvironmentHolder environmentHolder;

   @Test
   void shouldAssertNavigationOutcome() {
       getApplicationConfigDecorator().registerNavigationCase(OUTCOME, TO_VIEW_JSF);
       getApplication().getNavigationHandler().handleNavigation(getFacesContext(), null, OUTCOME);
       assertNavigatedWithOutcome(OUTCOME);
   }

   @Test
   void shouldAssertRedirect() throws IOException {
       getExternalContext().redirect(TO_VIEW_JSF);
       assertRedirect(TO_VIEW_JSF);
   }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing_a_validator">Testing a Validator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Testing a validator is straight-forward. You focus on the actual data to be checked, by using the fluent-api on TestItems. The api-tests are implicitly run. Additional configuration can be done using the mechanisms described previously.
The callback method for configuring the validator is optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class AbstractValidatorTestTest extends AbstractValidatorTest&lt;LengthValidator, String&gt; {

   @Override
   public void populate(final TestItems&lt;String&gt; testItems) {
       testItems.addValid("1").addValid("abc").addInvalidWithMessage("123456",
               LengthValidator.MAXIMUM_MESSAGE_ID);
   }

   @Override
   public void configure(final LengthValidator validator) {
       validator.setMaximum(5);
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Take a closer look at the parameter addInvalidWithMessage. It passes and checks the key not a resolved message, see <code>de.cuioss.test.jsf.junit5.EnableJsfEnvironment#useIdentityResouceBundle</code> for an explanation of the resource-bundle handling.</p>
</div>
<div class="sect2">
<h3 id="testing_a_converter">Testing a Converter</h3>
<div class="paragraph">
<p>Testing a converter is straight-forward. You focus on the actual data to be checked, by using the fluent-api on TestItems. The api-tests are implicitly run. Additional configuration can be done using the mechanisms described previously.
The callback method for configuring the converter is again optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class AbstractConverterTestTest extends AbstractConverterTest&lt;IntegerConverter, Integer&gt; {

   @Override
   public void populate(final TestItems&lt;Integer&gt; testItems) {
       testItems.addRoundtripValues("1", "122", "2132121").addInvalidString("a")
               .addInvalidStringWithMessage("a", "javax.faces.converter.IntegerConverter.INTEGER")
               .addInvalidObject(Boolean.TRUE)
               .addInvalidObjectWithMessage(Boolean.FALSE, "javax.faces.converter.STRING")
               .addValidString("13").addValidStringWithObjectResult("17", 17)
               .addValidObject(2)
               .addValidObjectWithStringResult(14, "14");
   }

   @Override
   public void configure(IntegerConverter toBeConfigured) {
       // Optional configuration for converter-test
   }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing_a_managed_named_bean">Testing a Managed / Named Bean</h3>
<div class="paragraph">
<p>Testing the attributes and canonical Object-Methods of a given Managed / Named Bean</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PropertyReflectionConfig(defaultValued = { MediumComplexityBean.STRING_WITH_DEFAULT_VALUE })
@ObjectTestConfig(equalsAndHashCodeExclude = MediumComplexityBean.ATTRIBUTE_NO_OBJECT_IDENTITY_STRING)
class AbstractBeanTestTest extends AbstractBeanTest&lt;MediumComplexityBean&gt; {

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing_a_component">Testing a Component</h3>
<div class="paragraph">
<p>Testing a component-class usually consists of testing the api-contract, the attribute handling (incl. Value-Expressions), and custom tests. Api and attributes are tested declarative.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@VerifyComponentProperties(of = { "offTextValue", "offTextKey" ,"onTextValue", "onTextKey","titleValue", "titleKey","rendered", "disabled" })
@JsfTestConfiguration(CoreJsfTestConfiguration.class)
class SwitchComponentTest extends AbstractComponentTest&lt;SwitchComponent&gt; {

   @Test // Tests actual logic
   void shouldResolvePassThroughAttributes() {
       SwitchComponent underTest = anyComponent();
       underTest.setDisabled(false);
       assertEquals(ImmutableMap.of("data-switch-disabled", "false"),
                underTest.resolvePassThroughAttributes());
       underTest.setDisabled(true);
       assertEquals(ImmutableMap.of("data-switch-disabled", "true"),
                underTest.resolvePassThroughAttributes());
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing_a_component_with_renderer">Testing a Component with Renderer</h3>
<div class="paragraph">
<p>This is a complex real-world-example bringing together many aspects of the test-framework</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@JsfTestConfiguration(CoreJsfTestConfiguration.class)
class SwitchRendererTest extends AbstractComponentRendererTest&lt;SwitchRenderer&gt; implements ComponentConfigurator {

    @Override
    public void configureComponents(final ComponentConfigDecorator decorator) {
        decorator.registerUIComponent(ColumnComponent.class).
        registerRenderer(LayoutComponentRenderer.class);
   }

    @Override
    protected UIComponent getComponent() {
        final SwitchComponent component = new SwitchComponent();
        component.setId(testComponent);
        component.setTitleValue(titleValue);
        component.setTitleKey(titleKey);
        component.setOnTextValue(onText);
        component.setOffTextValue(offText);
        component.setOnTextKey(onTextKey);
        component.setOffTextKey(offTextKey);
        component.setStyle(style);
        component.setSize(3);
        component.setStyleClass(styleClass);
        return component;
    }

   @Test
   void shouldRenderMinimal() {
       final SwitchComponent component = (SwitchComponent) getComponent();
       component.processEvent(new PostAddToViewEvent(component));
       component.processEvent(new PreRenderComponentEvent(component));

       final HtmlTreeBuilder expected = buildHtmlTree(false, false);
       assertRenderResult(component, expected.getDocument());
   }

   @Test
   void shouldRenderDisabled() {
       final SwitchComponent component = (SwitchComponent) getComponent();
       component.setDisabled(true);

       component.processEvent(new PostAddToViewEvent(component));
       component.processEvent(new PreRenderComponentEvent(component));

       final HtmlTreeBuilder expected = buildHtmlTree(false, true);
       assertRenderResult(component, expected.getDocument());
   }
   /**
    * &lt;div id="testComponent_container"
    * name="testComponent_container"
    * data-switch-disabled="true|false"&gt;
    * &lt;div class="col-sm-6 switch-placing"&gt;
    * &lt;label class="switch"&gt;
    * &lt;input id="testComponent" name="testComponent"/&gt;
    * &lt;span class="slider round"/&gt;
    * &lt;/label&gt;
    * &lt;span class="switch-text" data-item-active="true"&gt;onText&lt;/span&gt;
    * &lt;span class="switch-text" data-item-active="false"&gt;offText&lt;/span&gt;
    * &lt;/div&gt;
    * &lt;/div&gt;
    */
   private HtmlTreeBuilder buildHtmlTree(final boolean isActive, final boolean isDisabled) {
     final HtmlTreeBuilder expected = new HtmlTreeBuilder()
     // container
     .withNode(Node.DIV)
     .withAttributeNameAndId("testComponent_container")
     .withAttribute("data-switch-disabled", String.valueOf(isDisabled))
     .withAttribute(AttributeName.CLASS, styleClass)
     .withAttribute(AttributeName.STYLE, style)

     // column
     .withNode(Node.DIV)
     .withAttribute(AttributeName.CLASS, default_column_size + " switch-placing")

     // label
     .withNode(Node.LABEL)
     .withAttribute(AttributeName.CLASS, "switch")
     .withAttribute(AttributeName.TITLE, titleValue)

     // checkbox
     .withNode(Node.INPUT)
     .withAttributeNameAndId("testComponent")
     .currentHierarchyUp()

     // slider
     .withNode(Node.SPAN)
     .withAttribute(AttributeName.CLASS, "slider round")
     .currentHierarchyUp()

     // leaving label
     .currentHierarchyUp()

     // on text
     .withNode(Node.SPAN)
     .withAttribute(AttributeName.CLASS, "switch-text" + (!isActive ? " hidden" : ""))
     .withAttribute(AttributeName.DATA_ITEM_ACTIVE, "true")
     .withTextContent(onText)
     .currentHierarchyUp()

     // off text
     .withNode(Node.SPAN)
     .withAttribute(AttributeName.CLASS, "switch-text" + (isActive ? " hidden" : ""))
     .withAttribute(AttributeName.DATA_ITEM_ACTIVE, "false")
     .withTextContent(offText)
     .currentHierarchyUp()

     // leaving column
     .currentHierarchyUp();

      return expected;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2022&#x2013;2023
<a href="https://github.com/cuioss">CUI-OpenSource-Software</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
