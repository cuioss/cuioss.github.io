<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JWT Validation Step Metrics Visualizer</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="resources/common.css">
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>JWT Validation Step Metrics</h1>
      <p class="subtitle">Interactive visualization of performance metrics for each validation step</p>
      <div class="navigation">
        <!-- Navigation will be injected by JavaScript -->
      </div>
    </div>

    <div id="loading" class="loading">
      <p>Loading metrics data...</p>
    </div>


    <div id="error" class="error" style="display: none;">
      <h3>Unable to Load Metrics Data</h3>
      <p>Could not fetch <a href="data/jwt-validation-metrics.json">jwt-validation-metrics.json</a>. Please ensure the metrics file is available.</p>
    </div>

    <div id="content" style="display: none;">
      <div class="controls">
        <div class="control-group">
          <label class="control-label">Select Test</label>
          <select id="testSelector">
            <option value="">Choose a test...</option>
          </select>
        </div>
        <div class="control-group">
          <label class="control-label">Chart Scale</label>
          <select id="scaleSelector">
            <option value="linear">Linear Scale</option>
            <option value="logarithmic">Logarithmic Scale</option>
          </select>
        </div>
      </div>

      <div id="testInfo" class="test-info" style="display: none;">
        <h3 id="testName"></h3>
        <div id="testTimestamp" class="test-timestamp"></div>
      </div>

      <div id="summaryStats" class="summary-stats" style="display: none;"></div>

      <div class="charts-container">
        <div class="chart-section">
          <div class="chart-title">Performance Percentiles (μs)</div>
          <div class="percentile-legend">
            <div class="legend-item">
              <div class="legend-color" style="background-color: #36a2eb;"></div>
              <span>P50 (Median)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #ff9f40;"></div>
              <span>P95</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #ff6384;"></div>
              <span>P99</span>
            </div>
          </div>
          <div class="chart-container">
            <canvas id="percentilesChart"></canvas>
          </div>
        </div>

        <div class="chart-section">
          <div class="chart-title">Sample Counts & Step Overview</div>
          <div class="chart-container">
            <canvas id="samplesChart"></canvas>
          </div>
        </div>
      </div>

      <div id="stepDetails" class="step-details" style="display: none;">
        <h4>Step Performance Analysis</h4>
        <p id="stepAnalysis"></p>
      </div>
    </div>
  </div>

  <script src="resources/navigation.js"></script>
  <script>
    let metricsData = null;
    let percentilesChart = null;
    let samplesChart = null;

    // Load metrics data
    async function loadMetricsData() {
      try {
        const response = await fetch('data/jwt-validation-metrics.json');
        if (!response.ok) {
          throw new Error('Failed to fetch metrics data');
        }
        metricsData = await response.json();
        populateTestSelector();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('content').style.display = 'block';
      } catch (error) {
        console.error('Error loading metrics data:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
      }
    }

    // Populate test selector dropdown
    function populateTestSelector() {
      const selector = document.getElementById('testSelector');
      const testNames = Object.keys(metricsData);
      
      testNames.forEach(testName => {
        const option = document.createElement('option');
        option.value = testName;
        option.textContent = formatTestName(testName);
        selector.appendChild(option);
      });
    }

    // Format test name for display
    function formatTestName(testName) {
      return testName
        .replace(/([A-Z])/g, ' $1')
        .replace(/^./, str => str.toUpperCase())
        .replace(/(\d+)/, ' $1%');
    }

    // Format step name for display
    function formatStepName(stepName) {
      return stepName
        .replace(/_/g, ' ')
        .replace(/\b\w/g, l => l.toUpperCase());
    }

    // Update visualization when test is selected
    function updateVisualization() {
      const selectedTest = document.getElementById('testSelector').value;
      const scaleType = document.getElementById('scaleSelector').value;
      
      if (!selectedTest || !metricsData[selectedTest]) {
        hideCharts();
        return;
      }

      const testData = metricsData[selectedTest];
      showTestInfo(selectedTest, testData);
      createSummaryStats(testData);
      createPercentilesChart(testData, scaleType);
      createSamplesChart(testData);
      showStepAnalysis(testData);
    }

    // Show test information
    function showTestInfo(testName, testData) {
      document.getElementById('testName').textContent = formatTestName(testName);
      document.getElementById('testTimestamp').textContent = 
        `Recorded: ${new Date(testData.timestamp).toLocaleString()}`;
      document.getElementById('testInfo').style.display = 'block';
    }

    // Create summary statistics
    function createSummaryStats(testData) {
      const steps = testData.steps;
      const stepNames = Object.keys(steps);
      
      const totalSteps = stepNames.length;
      const avgSampleCount = Math.round(
        stepNames.reduce((sum, step) => sum + steps[step].sample_count, 0) / stepNames.length
      );
      
      // Find slowest step (highest P99)
      const slowestStep = stepNames.reduce((max, step) => 
        steps[step].p99_us > steps[max].p99_us ? step : max
      );
      
      // Find fastest step (lowest P50, excluding zero values)
      const fastestStep = stepNames
        .filter(step => steps[step].p50_us > 0)
        .reduce((min, step) => 
          steps[step].p50_us < steps[min].p50_us ? step : min
        );

      const statsHtml = `
        <div class="stat-card">
          <div class="stat-value">${totalSteps}</div>
          <div class="stat-label">Total Steps</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgSampleCount.toLocaleString()}</div>
          <div class="stat-label">Avg Samples</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatStepName(slowestStep)}</div>
          <div class="stat-label">Slowest Step</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatStepName(fastestStep)}</div>
          <div class="stat-label">Fastest Step</div>
        </div>
      `;
      
      document.getElementById('summaryStats').innerHTML = statsHtml;
      document.getElementById('summaryStats').style.display = 'grid';
    }

    // Create percentiles chart
    function createPercentilesChart(testData, scaleType) {
      const ctx = document.getElementById('percentilesChart').getContext('2d');
      const steps = testData.steps;
      const stepNames = Object.keys(steps).sort();
      
      // Prepare data
      const p50Data = stepNames.map(step => steps[step].p50_us);
      const p95Data = stepNames.map(step => steps[step].p95_us);
      const p99Data = stepNames.map(step => steps[step].p99_us);
      const labels = stepNames.map(formatStepName);

      // Destroy existing chart
      if (percentilesChart) {
        percentilesChart.destroy();
      }

      percentilesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'P50 (Median)',
              data: p50Data,
              backgroundColor: 'rgba(54, 162, 235, 0.8)',
              borderColor: 'rgba(54, 162, 235, 1)',
              borderWidth: 1
            },
            {
              label: 'P95',
              data: p95Data,
              backgroundColor: 'rgba(255, 159, 64, 0.8)',
              borderColor: 'rgba(255, 159, 64, 1)',
              borderWidth: 1
            },
            {
              label: 'P99',
              data: p99Data,
              backgroundColor: 'rgba(255, 99, 132, 0.8)',
              borderColor: 'rgba(255, 99, 132, 1)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false // We have our own legend
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  return stepNames[context[0].dataIndex];
                },
                label: function(context) {
                  const step = steps[stepNames[context.dataIndex]];
                  return `${context.dataset.label}: ${context.parsed.y.toLocaleString()}μs (${step.sample_count.toLocaleString()} samples)`;
                }
              }
            }
          },
          scales: {
            y: {
              type: scaleType,
              beginAtZero: true,
              title: {
                display: true,
                text: 'Time (μs)'
              },
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            x: {
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
    }

    // Create samples chart with dual axis
    function createSamplesChart(testData) {
      const ctx = document.getElementById('samplesChart').getContext('2d');
      const steps = testData.steps;
      const stepNames = Object.keys(steps).sort();
      
      // Prepare data
      const sampleCounts = stepNames.map(step => steps[step].sample_count);
      const p50Data = stepNames.map(step => steps[step].p50_us);
      const labels = stepNames.map(formatStepName);

      // Destroy existing chart
      if (samplesChart) {
        samplesChart.destroy();
      }

      samplesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Sample Count',
              data: sampleCounts,
              backgroundColor: 'rgba(75, 192, 192, 0.6)',
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1,
              yAxisID: 'y'
            },
            {
              label: 'P50 Performance',
              data: p50Data,
              type: 'line',
              backgroundColor: 'rgba(255, 206, 86, 0.2)',
              borderColor: 'rgba(255, 206, 86, 1)',
              borderWidth: 3,
              pointBackgroundColor: 'rgba(255, 206, 86, 1)',
              pointBorderColor: '#fff',
              pointBorderWidth: 2,
              pointRadius: 6,
              yAxisID: 'y1',
              tension: 0.4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  return stepNames[context[0].dataIndex];
                },
                label: function(context) {
                  if (context.dataset.label === 'Sample Count') {
                    return `Samples: ${context.parsed.y.toLocaleString()}`;
                  } else {
                    return `P50: ${context.parsed.y.toLocaleString()}μs`;
                  }
                }
              }
            }
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Sample Count'
              },
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'P50 Time (μs)'
              },
              grid: {
                drawOnChartArea: false,
              },
              ticks: {
                callback: function(value) {
                  return value.toLocaleString();
                }
              }
            },
            x: {
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });
    }

    // Show step analysis
    function showStepAnalysis(testData) {
      const steps = testData.steps;
      const stepNames = Object.keys(steps);
      
      // Analyze performance characteristics
      const highVarianceSteps = stepNames.filter(step => {
        const stepData = steps[step];
        const variance = stepData.p99_us / (stepData.p50_us || 1);
        return variance > 10 && stepData.p50_us > 0;
      });

      const slowSteps = stepNames.filter(step => steps[step].p99_us > 1000);
      const fastSteps = stepNames.filter(step => 
        steps[step].p99_us < 10 && steps[step].p50_us > 0
      );

      let analysis = 'Performance Analysis: ';
      
      if (slowSteps.length > 0) {
        analysis += `Slowest operations are ${slowSteps.map(formatStepName).join(', ')}. `;
      }
      
      if (highVarianceSteps.length > 0) {
        analysis += `High latency variance detected in ${highVarianceSteps.map(formatStepName).join(', ')}. `;
      }
      
      if (fastSteps.length > 0) {
        analysis += `Consistently fast operations: ${fastSteps.map(formatStepName).join(', ')}.`;
      }

      document.getElementById('stepAnalysis').textContent = analysis;
      document.getElementById('stepDetails').style.display = 'block';
    }

    // Hide charts when no test selected
    function hideCharts() {
      document.getElementById('testInfo').style.display = 'none';
      document.getElementById('summaryStats').style.display = 'none';
      document.getElementById('stepDetails').style.display = 'none';
      
      if (percentilesChart) {
        percentilesChart.destroy();
        percentilesChart = null;
      }
      if (samplesChart) {
        samplesChart.destroy();
        samplesChart = null;
      }
    }

    // Event listeners
    document.getElementById('testSelector').addEventListener('change', updateVisualization);
    document.getElementById('scaleSelector').addEventListener('change', updateVisualization);

    // Load data when page loads
    document.addEventListener('DOMContentLoaded', loadMetricsData);
  </script>
</body>
</html>